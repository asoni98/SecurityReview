{"function_name":"users_username_from_id","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/users.py","line_number":17,"column":null,"snippet":"@router.get(\"/profile/{user}\")\nasync def users_username_from_id(\n    user: uuid.UUID, db: AsyncDBSession = Depends(deps.get_db)\n) -> JSONResponse:\n    try:\n        db_user = (await db.scalars(select(User).where(User.id == user))).first()\n        if not db_user:\n            return JSONResponse(\n                content={\"success\": False, \"detail\": \"User not found\"},\n                status_code=404,\n            )\n\n        return JSONResponse(\n            content={\"success\": True, \"username\": db_user.username, \"bio\": db_user.bio}\n        )\n    except Exception as e:\n        await logger.aexception(\"Error fetching user profile\", user=user)\n        return JSONResponse(\n            {\n                \"success\": False,\n                \"detail\": str(e) if settings.DEBUG else \"Internal server error\",\n            },\n            status_code=500,\n        )"},"framework":"FastAPI","language":"python","input_sources":["path_params"],"accepts_unauthenticated_input":true,"risk_level":"medium","security_concerns":[{"vulnerability_type":"authorization_bypass","description":"Endpoint allows unauthenticated users to fetch profile information for any user ID; if profiles are intended to be private, this could be an authorization issue.","confidence":0.7},{"vulnerability_type":"idor","description":"Fetching another user’s profile data by supplying a UUID in the path may constitute an IDOR if access should be restricted.","confidence":0.6},{"vulnerability_type":"business_logic","description":"Potential user enumeration or privacy concerns depending on intended visibility of username/bio; confirm requirements.","confidence":0.5}],"endpoint_path":"/profile/{user}","http_methods":["GET"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":false,"reasoning":"This is a real FastAPI route handler (despite the scanner labeling it Flask). It accepts a path parameter 'user' typed as UUID and uses it in a SQLAlchemy SELECT to read a user record, returning username and bio. No authentication or authorization is enforced for this endpoint. While the operation is read-only and uses ORM (mitigating injection), it is unauthenticated database access with potential privacy/authorization implications. Prioritize as MEDIUM for review to confirm intended access control and data exposure. Input validation is present via UUID typing; no explicit sanitization is needed."}
{"function_name":"api_health_check","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/api.py","line_number":7,"column":null,"snippet":"@api_router.get(\"/health\", status_code=status.HTTP_200_OK)\nasync def api_health_check() -> Response:\n    return Response(status_code=status.HTTP_200_OK)\n\n\napi_router.include_router(auth.router, prefix=\"/auth\", tags=[\"login\"])"},"framework":"Fastapi","language":"python","input_sources":["http_headers"],"accepts_unauthenticated_input":true,"risk_level":"low","security_concerns":[],"endpoint_path":"/health","http_methods":["GET"],"has_input_validation":null,"has_sanitization":null,"has_authorization_check":false,"reasoning":"This file defines a real FastAPI endpoint: GET /health via api_health_check(). The handler takes no parameters and returns a static 200 Response; it does not parse body, query, path params, or perform any sensitive operations (no DB, filesystem, external calls). There are no auth dependencies or checks, so it is reachable unauthenticated. The include_router calls are routing configuration and do not themselves handle input. Given it’s unauthenticated but trivial read-only with no user-controlled processing, prioritize as LOW. Next reviewer only needs to confirm it exposes no sensitive health info (it doesn’t) and that no hidden dependencies add side effects."}
{"function_name":"feed_latest","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/feed.py","line_number":22,"column":null,"snippet":"@router.get(\"/latest\")\nasync def feed_latest(\n    before: datetime = datetime.now(tz=timezone.utc) + timedelta(days=1),\n    after: datetime = datetime.fromtimestamp(0, tz=timezone.utc),\n    user: UserDetail | None = Depends(deps.verify_jwt_to_uuid_or_none),\n    db: AsyncDBSession = Depends(deps.get_db),\n    aws: AWSSession = Depends(deps.get_aws_session),\n    redis: Redis = Depends(deps.get_redis),\n) -> Response:\n    try:\n        before = before.astimezone(timezone.utc).replace(tzinfo=None)\n        after = after.astimezone(timezone.utc).replace(tzinfo=None)\n\n        image_filters = [\n            Image.created_at < before,\n            Image.created_at > after,\n            Image.public,\n        ]\n\n        if user is not None:\n            image_filters[-1] = or_(Image.public, Image.owner_id == user.id)\n\n        return JSONResponse(await build_feed(image_filters, db, aws, redis))\n    except Exception as e:\n        await logger.aexception(\"Error building latest feed\", user=user.id)\n        return JSONResponse({\"success\": False, \"detail\": str(e) if settings.DEBUG else \"Internal server error\"})"},"framework":"Fastapi","language":"python","input_sources":["query_params","http_headers"],"accepts_unauthenticated_input":true,"risk_level":"high","security_concerns":[{"vulnerability_type":"business_logic","description":"Authorization is enforced via filter logic (public OR owner==user.id). Reviewer should verify this logic cannot expose non-public images and that JWT parsing in deps.verify_jwt_to_uuid_or_none is correct.","confidence":0.6},{"vulnerability_type":"other","description":"Potential for resource-intensive queries or enumeration due to unbounded date ranges (before/after) and unauthenticated access. Ensure rate limiting/pagination and safe defaults in build_feed.","confidence":0.5}],"endpoint_path":"/latest","http_methods":["GET"],"has_input_validation":true,"has_sanitization":false,"has_authorization_check":true,"reasoning":"This is a real FastAPI GET endpoint at /latest. It accepts unauthenticated requests and parses query parameters before/after (datetimes). Optional auth via JWT dependency may grant access to private data for the authenticated owner by adjusting DB filters. The handler constructs SQLAlchemy filters and calls build_feed, which likely performs DB reads and uses AWS/Redis. Because it is unauthenticated read with non-trivial authorization logic determining data exposure and cross-service operations, prioritize as HIGH for review."}
{"function_name":"feed_by_user","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/feed.py","line_number":56,"column":null,"snippet":"@router.get(\"/by_user/{creator}\")\nasync def feed_by_user(\n    creator: uuid.UUID,\n    before: datetime = datetime.now(tz=timezone.utc) + timedelta(days=1),\n    after: datetime = datetime.fromtimestamp(0, tz=timezone.utc),\n    user: UserDetail | None = Depends(deps.verify_jwt_to_uuid_or_none),\n    db: AsyncDBSession = Depends(deps.get_db),\n    aws: Optional[AWSSession] = Depends(deps.get_aws_session),\n    redis: Redis = Depends(deps.get_redis),\n) -> Response:\n    try:\n        before = before.astimezone(timezone.utc).replace(tzinfo=None)\n        after = after.astimezone(timezone.utc).replace(tzinfo=None)\n\n        image_filters = [\n            Image.created_at < before,\n            Image.created_at > after,\n            Image.owner_id == creator,\n            or_(Image.owner_id == user.id, Image.public),\n        ]\n\n        return JSONResponse(await build_feed(image_filters, db, aws, redis))\n    except Exception as e:\n        await logger.aexception(\n            \"Error building by_user feed\", user=user.id, creator=creator\n        )\n        return JSONResponse({\"success\": False, \"detail\": str(e) if settings.DEBUG else \"Internal server error\"}, status_code=500)"},"framework":"Fastapi","language":"python","input_sources":["path_params","query_params","http_headers"],"accepts_unauthenticated_input":true,"risk_level":"high","security_concerns":[{"vulnerability_type":"authorization_bypass","description":"Access control relies on combining filters (owner_id == creator AND (owner_id == user.id OR public)). Review to ensure private images are only returned to the creator and not leaked to other authenticated users or unauthenticated callers.","confidence":0.55},{"vulnerability_type":"business_logic","description":"Date window (before/after) affects which records are returned; verify timezone conversions and defaults don’t unintentionally widen scope or cause logic errors.","confidence":0.6},{"vulnerability_type":"other","description":"Potential DoS/performance risk from unauthenticated callers specifying wide date ranges leading to heavy DB queries or cache misses; ensure pagination/limits and caching are enforced.","confidence":0.6},{"vulnerability_type":"sql_injection","description":"Likely mitigated by SQLAlchemy expressions, but confirm build_feed doesn’t construct raw SQL with user input.","confidence":0.35}],"endpoint_path":"/by_user/{creator}","http_methods":["GET"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":true,"reasoning":"This is a real FastAPI GET route that accepts unauthenticated requests. It takes a path param (creator UUID) and query params (before/after datetimes) and optionally an auth header (JWT) via dependency to tailor visibility of private images. It builds SQLAlchemy filters and calls build_feed using DB, AWS, and Redis, returning JSON. Because it is publicly reachable and performs non-trivial read operations involving the database and external services, it warrants a HIGH-priority review. Focus on access control correctness, input handling of UUID/datetime, query construction in build_feed, and performance limits."}
{"function_name":"users_username_from_id","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/users.py","line_number":23,"column":null,"snippet":"@router.get(\"/profile/{user}\")\nasync def users_username_from_id(\n    user: uuid.UUID, db: AsyncDBSession = Depends(deps.get_db)\n) -> JSONResponse:\n    try:\n        db_user = (await db.scalars(select(User).where(User.id == user))).first()\n        if not db_user:\n            return JSONResponse(\n                content={\"success\": False, \"detail\": \"User not found\"},\n                status_code=404,\n            )\n\n        return JSONResponse(\n            content={\"success\": True, \"username\": db_user.username, \"bio\": db_user.bio}\n        )\n    except Exception as e:\n        await logger.aexception(\"Error fetching user profile\", user=user)\n        return JSONResponse(\n            {\n                \"success\": False,\n                \"detail\": str(e) if settings.DEBUG else \"Internal server error\",\n            },\n            status_code=500,\n        )"},"framework":"Fastapi","language":"python","input_sources":["path_params"],"accepts_unauthenticated_input":true,"risk_level":"medium","security_concerns":[{"vulnerability_type":"authorization_bypass","description":"No authentication or authorization checks; any client can retrieve a user's username and bio by providing a UUID. Verify if this data is intended to be public.","confidence":0.7},{"vulnerability_type":"business_logic","description":"Possible user enumeration and privacy exposure (404 vs 200 reveals account existence; returns profile details without auth). Confirm exposure policy and need for rate limiting.","confidence":0.7}],"endpoint_path":"/profile/{user}","http_methods":["GET"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":false,"reasoning":"This is a real FastAPI GET endpoint that accepts a UUID path parameter and performs a database lookup using SQLAlchemy, returning username and bio. There is no authentication or authorization dependency, so it is reachable by unauthenticated users. While it is read-only and uses ORM (reducing injection risk), it could expose user information and supports account existence probing. Prioritize as MEDIUM: unauthenticated read with simple logic and DB access, warranting review of data exposure and authorization expectations."}
{"function_name":"images_generate_upload_link","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/images.py","line_number":21,"column":null,"snippet":"@router.post(\"/upload/{privacy}/generate\")\nasync def images_generate_upload_link(\n    privacy: str,\n    caption: str = \"\",\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n    aws: AWSSession = Depends(deps.get_aws_session),\n) -> Response:\n    if privacy not in [\"public\", \"private\"]:\n        return JSONResponse(\n            content={\n                \"success\": False,\n                \"detail\": \"privacy parameter should be 'public' or 'private'\",\n            },\n            status_code=400,\n        )\n\n    public = privacy == \"public\"\n    image_id = str(ULID().to_uuid4())\n    db_image = Image(\n        id=image_id,\n        public=public,\n        caption=caption,\n        owner_id=user.id,\n        content_type=\"image/jpeg\",\n    )\n\n    presigned_post = create_presigned_post(aws, image_id)\n    db_image.path = presigned_post[\"s3_uri\"]\n    create_response = presigned_post[\"create_response\"] | {\"id\": image_id}"},"framework":"Fastapi","language":"python","input_sources":["path_params","query_params","http_headers"],"accepts_unauthenticated_input":false,"risk_level":"high","security_concerns":[{"vulnerability_type":"business_logic","description":"Generates S3 presigned upload credentials based on user request. Ensure strict constraints (bucket/key scoping, content-type and size limits, ACL/visibility tied to privacy, short expiration, rate limiting) and least-privilege IAM for the AWS session.","confidence":0.85},{"vulnerability_type":"xss","description":"Unvalidated caption is accepted and likely stored; if later rendered without escaping it could enable stored XSS. Validate/limit length and sanitize or encode on output.","confidence":0.6}],"endpoint_path":"/upload/{privacy}/generate","http_methods":["POST"],"has_input_validation":true,"has_sanitization":false,"has_authorization_check":true,"reasoning":"This is a real FastAPI POST endpoint that accepts user-controlled path (privacy) and query (caption) parameters and depends on an authenticated user via get_current_user. It creates an Image object and generates an AWS S3 presigned POST for client-side uploads—operations that are sensitive even if read/write DB actions aren’t fully shown in the snippet. Authentication is required, but the functionality enables file upload capability and likely a DB write, warranting a HIGH priority review. Validation only covers the privacy enum; no validation/sanitization is apparent for caption or upload constraints, so reviewers should verify strict constraints and IAM scoping in create_presigned_post and how caption is persisted/rendered."}
{"function_name":"images_confirm_uploaded","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/images.py","line_number":59,"column":null,"snippet":"@router.post(\"/upload/{image_id}/confirm\")\nasync def images_confirm_uploaded(\n    image_id: UUID4,\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n    aws: AWSSession = Depends(deps.get_aws_session),\n) -> Response:\n    db_image = (await db.scalars(select(Image).where(Image.id == image_id))).first()\n    if (not db_image) or (db_image.owner_id != user.id):\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    if db_image.uploaded:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image upload already confirmed\"},\n            status_code=404,\n        )\n\n    if not verify_exists(aws, db_image.path):\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image with that ID doesn't exist in S3\"},\n            status_code=404,\n        )\n\n    db_image.uploaded = True\n    db.add(db_image)\n    await db.commit()\n    await db.refresh(db_image)"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers"],"accepts_unauthenticated_input":false,"risk_level":"medium","security_concerns":[{"vulnerability_type":"idor","description":"Confirms upload status of an image by ID. While there is an ownership check (db_image.owner_id == user.id), reviewers should verify this cannot be bypassed and that get_current_user is robust.","confidence":0.7},{"vulnerability_type":"ssrf","description":"verify_exists uses an AWS session to check object existence. Ensure it only talks to intended S3 endpoints and cannot be directed to arbitrary URLs/hosts.","confidence":0.5},{"vulnerability_type":"business_logic","description":"Potential race/TOCTOU between verifying existence in S3 and marking uploaded; confirm consistency and replay protection for repeated confirmations.","confidence":0.5}],"endpoint_path":"/upload/{image_id}/confirm","http_methods":["POST"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":true,"reasoning":"This is a real FastAPI route handler that accepts a path parameter (image_id) and uses authenticated user context (Depends(get_current_user)). It performs DB read/write operations and an external call to AWS (verify_exists), then sets a DB flag. Authentication is required and an authorization/ownership check is present, reducing exposure. Because it is authenticated and performs standard CRUD with some external interaction, it merits a MEDIUM priority review. Reviewers should focus on authorization robustness (no IDOR), correctness of S3 existence checks, and any side effects of marking uploads as confirmed."}
{"function_name":"images_retrieve","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/images.py","line_number":93,"column":null,"snippet":"# Image retrieval route\n@router.get(\"/media/{image_id}\")\nasync def images_retrieve(\n    image_id: UUID4,\n    user: UserDetail | None = Depends(deps.verify_jwt_to_uuid_or_none),\n    db: AsyncDBSession = Depends(deps.get_db),\n    aws: AWSSession = Depends(deps.get_aws_session),\n    redis: Redis = Depends(deps.get_redis),\n) -> Response:\n    try:\n        user_id = user.id if user is not None else None\n        db_image = await get_image(db, image_id, user_id)\n        if not db_image:\n            return JSONResponse(\n                {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n            )\n\n        return JSONResponse(\n            {\n                \"success\": True,\n                \"uri\": await presigned_url_with_cache(\n                    aws, redis, db_image.path, db_image.content_type\n                ),\n            }\n        )\n\n    except Exception as e:\n        await logger.aexception(\"Error retrieving image\", image=image_id, user=user_id)\n        return JSONResponse(\n            {\n                \"success\": False,"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers"],"accepts_unauthenticated_input":true,"risk_level":"high","security_concerns":[{"vulnerability_type":"idor","description":"Unauthenticated users can call this route with an image_id and receive a presigned S3 URL if access control in get_image is insufficient. Verify that get_image enforces ownership/visibility rules when user is None and that image IDs are unguessable.","confidence":0.7},{"vulnerability_type":"authorization_bypass","description":"Authorization appears to be delegated to get_image with optional user context. If get_image does not strictly check permissions for unauthenticated callers, this endpoint may leak private images.","confidence":0.6},{"vulnerability_type":"business_logic","description":"Returning a presigned S3 URL effectively grants direct access to the asset. Ensure TTL, scoping, and path/content_type correctness to avoid unintended exposure or cache poisoning via Redis.","confidence":0.5}],"endpoint_path":"/media/{image_id}","http_methods":["GET"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":null,"reasoning":"This is a real FastAPI route handler (@router.get) that accepts a path parameter image_id (validated as UUID4) and optional Authorization header (JWT is optional via verify_jwt_to_uuid_or_none), so unauthenticated users can reach it. It uses user input to query the database via get_image and returns a presigned S3 URL (external API) with Redis caching. Because it is unauthenticated read that can expose sensitive resources (presigned URLs granting access) and relies on downstream authorization logic, it warrants a HIGH priority review. Focus on access control in get_image, ID predictability, and correctness of presigned_url_with_cache and cache policy."}
{"function_name":"auth_register","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/auth.py","line_number":19,"column":null,"snippet":"@router.post(\"/register/\", status_code=201)\nasync def auth_register(\n    user: UserCreate, db: AsyncDBSession = Depends(deps.get_db)\n) -> Response:\n    try:\n        db_user = (\n            await db.scalars(\n                select(User).where(\n                    or_(User.username == user.username, User.email == user.email)\n                )\n            )\n        ).first()\n        if db_user:\n            return JSONResponse(\n                content={\n                    \"success\": False,\n                    \"detail\": \"Email or username already registered\",\n                },\n                status_code=400,\n            )\n\n        hashed_password = get_password_hash(user.password)\n\n        db_user = User(\n            **user.model_dump(exclude={\"password\"}), password_hash=hashed_password\n        )\n        db.add(db_user)\n        await db.commit()\n        await db.refresh(db_user)"},"framework":"Fastapi","language":"python","input_sources":["http_body"],"accepts_unauthenticated_input":true,"risk_level":"critical","security_concerns":[{"vulnerability_type":"mass_assignment","description":"Uses **user.model_dump(exclude={\"password\"}) to construct the ORM model. Ensure the Pydantic schema only exposes intended fields and no sensitive/privileged columns can be set by clients.","confidence":0.8},{"vulnerability_type":"business_logic","description":"Registration is unauthenticated and writes to DB. Review for rate limiting, bot/abuse protections, and whether the error message enables account/email enumeration.","confidence":0.7},{"vulnerability_type":"sql_injection","description":"User-supplied username/email are used in a SQLAlchemy query. ORM parameterization typically mitigates SQLi, but confirm no string concatenation or unsafe text constructs are used elsewhere.","confidence":0.4}],"endpoint_path":"/register/","http_methods":["POST"],"has_input_validation":true,"has_sanitization":false,"has_authorization_check":false,"reasoning":"This is a real FastAPI POST endpoint that accepts a Pydantic body (UserCreate) from unauthenticated users to register accounts. It performs database read and write operations based on user input (duplicate check, password hashing, create User, commit). Because it is unauthenticated and performs sensitive DB writes, it warrants CRITICAL priority. Reviewers should focus on the body fields (username, email, password), schema enforcement, potential mass assignment via model_dump, password hashing policy, and abuse prevention (rate limiting, email/username enumeration)."}
{"function_name":"auth_login","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/auth.py","line_number":60,"column":null,"snippet":"@router.post(\"/login/\", response_model=Token)\nasync def auth_login(\n    user: UserLogin, db: AsyncDBSession = Depends(deps.get_db)\n) -> Token:\n    try:\n        await logger.ainfo(\"Login attempt\", username=user.username)\n        db_user = (\n            await db.scalars(select(User).where(User.username == user.username))\n        ).first()\n        if not db_user or not verify_password(user.password, db_user.password_hash):\n            await logger.ainfo(\"Login failed\", username=user.username)\n            return JSONResponse(\n                content={\"success\": False, \"detail\": \"Invalid username or password\"},\n                status_code=401,\n            )\n\n        await logger.ainfo(\"Login successful\", username=user.username)\n        access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)\n        access_token = create_access_token(\n            str(db_user.id), expires_delta=access_token_expires\n        )\n\n        return Token(access_token=access_token, token_type=\"bearer\")\n    except Exception as e:\n        await logger.aexception(\"Exception during login\", username=user.username)\n        return JSONResponse(\n            {\n                \"success\": False,\n                \"detail\": str(e) if settings.DEBUG else \"Internal server error\",\n            },"},"framework":"Fastapi","language":"python","input_sources":["http_body"],"accepts_unauthenticated_input":true,"risk_level":"high","security_concerns":[{"vulnerability_type":"authentication_bypass","description":"Authentication logic and token issuance depend on verify_password and create_access_token; any flaw here could allow unauthorized access.","confidence":0.6},{"vulnerability_type":"business_logic","description":"No visible rate limiting or brute-force protections on login; potential for credential stuffing attacks. Ensure error responses do not leak user existence; currently uses a generic message.","confidence":0.7},{"vulnerability_type":"other","description":"Token generation/expiration configuration (secret, algorithm, claim contents) must be correct; misuse can weaken auth.","confidence":0.6}],"endpoint_path":"/login/","http_methods":["POST"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":false,"reasoning":"1) This is a real FastAPI route handler (decorated with @router.post) that processes login requests. 2) It accepts JSON body mapped to the Pydantic model UserLogin (likely username and password). 3) It does not require authentication; it is meant for anonymous users to log in. 4) It uses the input to query the database for a user record, verify a password hash, log events, and generate a JWT access token. 5) Prioritized as HIGH: it is unauthenticated but performs sensitive authentication logic and token issuance (read-only DB plus security-critical logic). 6) Next reviewer should examine: the UserLogin model validation (length/format), the SQLAlchemy query and parameterization, the verify_password implementation (hash algorithm, salting, constant-time compare), create_access_token (secret management, algorithm, claims, expiry), logging not exposing sensitive data, and whether rate limiting/lockout and generic error messages prevent enumeration and brute-force attacks."}
{"function_name":"images_like","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":16,"column":null,"snippet":"@router.post(\"/{image_id}/like\")\nasync def images_like(\n    image_id: UUID4,\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n) -> Response:\n    db_image = await get_image(db, image_id, user.id)\n    if not db_image:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    if (\n        await db.scalars(\n            select(Like).where(Like.user_id == user.id, Like.image_id == image_id)\n        )\n    ).first():\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"User has already liked this image\"},\n            status_code=400,\n        )\n\n    (await db_image.awaitable_attrs.likes).append(\n        Like(user_id=user.id, image_id=image_id, image=db_image)\n    )\n    await db.commit()\n    await db.refresh(db_image)\n\n    return JSONResponse({\"success\": True})"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers","cookies"],"accepts_unauthenticated_input":false,"risk_level":"high","security_concerns":[{"vulnerability_type":"idor","description":"Path parameter image_id controls which image is liked. If get_image does not enforce per-user access or visibility rules, a user may like images they should not access (IDOR/authorization issue).","confidence":0.6},{"vulnerability_type":"business_logic","description":"Duplicate-like prevention relies on an application-level query and may be vulnerable to race conditions without a DB-level uniqueness constraint on (user_id, image_id).","confidence":0.5}],"endpoint_path":"/{image_id}/like","http_methods":["POST"],"has_input_validation":true,"has_sanitization":false,"has_authorization_check":true,"reasoning":"This is a real FastAPI route handler that accepts a path parameter (UUID4 image_id) and an authenticated user via dependency injection. It performs database reads and writes (checks existing Like, appends a new Like, commits), making it a sensitive operation. Authentication is required via deps.get_current_user, and authorization likely occurs via get_image(db, image_id, user.id), but the robustness of that check should be verified. Prioritize as HIGH because it is authenticated and performs DB writes. Reviewers should focus on access control around image_id, race conditions/uniqueness on likes, and any assumptions in get_image."}
{"function_name":"images_like","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":47,"column":0,"snippet":"@router.post(\"/{image_id}/like\")\nasync def images_like(\n    image_id: UUID4,\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n) -> Response:\n    db_image = await get_image(db, image_id, user.id)\n    if not db_image:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    if (\n        await db.scalars(\n            select(Like).where(Like.user_id == user.id, Like.image_id == image_id)\n        )\n    ).first():\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"User has already liked this image\"},\n            status_code=400,\n        )\n\n    (await db_image.awaitable_attrs.likes).append(\n        Like(user_id=user.id, image_id=image_id, image=db_image)\n    )\n    await db.commit()\n    await db.refresh(db_image)\n\n    return JSONResponse({\"success\": True})"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers"],"accepts_unauthenticated_input":false,"risk_level":"high","security_concerns":[{"vulnerability_type":"idor","description":"Ensure get_image(db, image_id, user.id) enforces proper authorization/visibility checks so a user cannot like images they should not access by guessing UUIDs.","confidence":0.6},{"vulnerability_type":"business_logic","description":"Race between duplicate-like check and insert may allow duplicates without a DB-level unique constraint on (user_id, image_id). Review transaction isolation/unique constraints.","confidence":0.5}],"endpoint_path":"/{image_id}/like","http_methods":["POST"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":true,"reasoning":"This is a real FastAPI route handler that processes a POST to '/{image_id}/like'. It accepts a path parameter (image_id, validated as UUID4) and relies on an auth dependency (get_current_user) via headers, so unauthenticated users cannot reach the core logic. The handler performs database read and write operations: it queries for an existing like, appends a new Like to the image's relationship, and commits the transaction. Because it is authenticated and performs DB writes, it warrants a HIGH priority review. Reviewers should focus on authorization enforcement in get_image and data integrity around duplicate likes."}
{"function_name":"images_unlike","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":74,"column":null,"snippet":"@router.post(\"/{image_id}/unlike\")\nasync def images_unlike(\n    image_id: UUID4,\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n) -> Response:\n    db_image = await get_image(db, image_id, user.id)\n    if not db_image:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    for like in await db_image.awaitable_attrs.likes:\n        if like.user_id == user.id:\n            await db.delete(like)\n            await db.commit()\n            await db.refresh(db_image)\n            break\n    else:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"User has not liked this image\"},\n            status_code=400,\n        )\n\n    return JSONResponse({\"success\": True})"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers"],"accepts_unauthenticated_input":false,"risk_level":"medium","security_concerns":[{"vulnerability_type":"authorization_bypass","description":"Authorization relies on get_image(db, image_id, user.id) and a like.user_id == user.id check. If get_image does not correctly scope images to the current user’s allowed visibility, a user might attempt to unlike on images they should not access.","confidence":0.62},{"vulnerability_type":"idor","description":"Path parameter image_id controls which image is targeted. Ensure the combination of get_image scoping and the like ownership check prevents unliking likes on resources the user should not control.","confidence":0.58},{"vulnerability_type":"business_logic","description":"Logic assumes a single like per user per image and iterates all likes to find a match. Edge cases (duplicates, race conditions) could lead to inconsistent state or misleading responses.","confidence":0.45}],"endpoint_path":"/{image_id}/unlike","http_methods":["POST"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":true,"reasoning":"This is a real FastAPI route handler that processes a POST request to /{image_id}/unlike. It accepts user-controlled path parameter image_id (validated as UUID4) and authenticated user context via dependency injection (likely from Authorization header). The handler looks up the image, iterates associated likes, and performs a database write (delete like and commit). Because authentication is required and it performs DB modifications, it warrants a MEDIUM priority review per rubric. Primary risks are authorization correctness around image access and ensuring the user can only affect their own like record."}
{"function_name":"images_get_likes","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":97,"column":null,"snippet":"@router.get(\"/{image_id}/likes\")\nasync def images_get_likes(\n    image_id: UUID4,\n    user: UserDetail | None = Depends(deps.verify_jwt_to_uuid_or_none),\n    db: AsyncDBSession = Depends(deps.get_db),\n) -> Response:\n    db_image = await get_image(db, image_id, user.id)\n    if not db_image:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    liking_users = [\n        {\n            \"id\": str(like.user_id),\n            \"username\": (await like.awaitable_attrs.user).username,\n        }\n        for like in await db_image.awaitable_attrs.likes\n    ]\n\n    return JSONResponse({\"success\": True, \"likes\": liking_users})"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers"],"accepts_unauthenticated_input":true,"risk_level":"medium","security_concerns":[{"vulnerability_type":"authorization_bypass","description":"Endpoint allows unauthenticated access and returns liker user info for any image_id. If get_image does not properly enforce visibility/ownership, this could expose likes on private images (IDOR).","confidence":0.55},{"vulnerability_type":"business_logic","description":"Potential misuse of user when unauthenticated (user can be None). Passing user.id to get_image may rely on helper handling None safely; otherwise logic errors could occur.","confidence":0.5}],"endpoint_path":"/{image_id}/likes","http_methods":["GET"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":false,"reasoning":"This is a real FastAPI route handler that accepts a path parameter image_id (validated as UUID4) and an optional JWT-derived user from headers. It performs database reads (get_image and fetching likes) and returns JSON. No explicit authorization checks are visible, and unauthenticated users can call it via verify_jwt_to_uuid_or_none, so it should be reviewed for IDOR/authorization enforcement in get_image and data exposure. Because it is unauthenticated but read-only with straightforward logic, prioritize as MEDIUM."}
{"function_name":"images_comment","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":124,"column":null,"snippet":"@router.post(\"/{image_id}/comment\")\nasync def images_comment(\n    image_id: UUID4,\n    comment: CommentCreate,\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n) -> Response:\n    db_image = await get_image(db, image_id, user.id)\n    if not db_image:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    (await db_image.awaitable_attrs.comments).append(\n        Comment(\n            id=ULID().to_uuid4(),\n            user_id=user.id,\n            image_id=image_id,\n            content=comment.content,\n        )\n    )\n    await db.commit()\n    await db.refresh(db_image)\n\n    return JSONResponse({\"success\": True})"},"framework":"Fastapi","language":"python","input_sources":["http_body","path_params"],"accepts_unauthenticated_input":false,"risk_level":"medium","security_concerns":[{"vulnerability_type":"idor","description":"Authorization hinges on get_image(db, image_id, user.id). Verify it enforces the correct permission model for who may comment on which images (no commenting on unauthorized images via crafted image_id).","confidence":0.6},{"vulnerability_type":"xss","description":"User-controlled comment.content is stored; if later rendered in HTML without proper escaping/sanitization it could enable stored XSS.","confidence":0.55},{"vulnerability_type":"business_logic","description":"No explicit validation/sanitization of comment.content (length, allowed characters, HTML). Review Pydantic model CommentCreate for constraints.","confidence":0.7}],"endpoint_path":"/{image_id}/comment","http_methods":["POST"],"has_input_validation":null,"has_sanitization":false,"has_authorization_check":true,"reasoning":"This is a real FastAPI route that handles user-supplied path param image_id and request body comment to create a comment record. It requires authentication via Depends(deps.get_current_user), performs database lookups and writes (append comment, commit), and returns JSON. Authenticated standard CRUD write operation with moderate complexity; prioritize as MEDIUM. Next review should verify authorization in get_image and handling/sanitization/validation of comment content."}
{"function_name":"images_comment","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":152,"column":null,"snippet":"@router.post(\"/{image_id}/comments/{comment_id}/update\")\nasync def images_comment(\n    image_id: UUID4,\n    comment_id: UUID4,\n    comment: CommentCreate,\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n) -> Response:\n    db_image = await get_image(db, image_id, user.id)\n    if not db_image:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    for db_comment in await db_image.awaitable_attrs.comments:\n        if db_comment.id == comment_id:\n            db_comment.content = comment.content\n            await db.commit()\n            await db.refresh(db_image)\n            break\n    else:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Comment not found\"}, status_code=404\n        )\n\n    return JSONResponse({\"success\": True})"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_body","http_headers"],"accepts_unauthenticated_input":false,"risk_level":"medium","security_concerns":[{"vulnerability_type":"authorization_bypass","description":"Authorization is enforced indirectly via get_image(db, image_id, user.id); verify that this correctly restricts updates to comments the user is allowed to modify (e.g., ownership vs. any comment on a user-owned image).","confidence":0.6},{"vulnerability_type":"idor","description":"Comment selection is by ID within the image’s comments list. Ensure a user cannot update another user’s comment unless intended business logic permits it.","confidence":0.55},{"vulnerability_type":"xss","description":"User-supplied comment.content is written to the database without sanitization here; if later rendered into HTML, ensure proper output encoding and validation to avoid XSS.","confidence":0.5},{"vulnerability_type":"business_logic","description":"Confirm business rules: should image owners be able to edit any comment on their image? Ensure this matches requirements and is documented.","confidence":0.6}],"endpoint_path":"/{image_id}/comments/{comment_id}/update","http_methods":["POST"],"has_input_validation":true,"has_sanitization":false,"has_authorization_check":true,"reasoning":"This is a FastAPI route handling POST updates to a comment. It accepts path params and a body model, requires authentication via Depends(deps.get_current_user), and performs database write operations (updating a comment and committing). Because it is authenticated standard CRUD with DB writes and non-trivial authorization assumptions, it warrants MEDIUM priority for review. Reviewers should focus on authorization scope (image ownership vs. comment ownership), input validation for comment content, and downstream rendering that could introduce XSS."}
{"function_name":"images_comment","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":179,"column":null,"snippet":"@router.post(\"/{image_id}/comments/{comment_id}/delete\")\nasync def images_comment(\n    image_id: UUID4,\n    comment_id: UUID4,\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n) -> Response:\n    db_image = await get_image(db, image_id, user.id)\n    if not db_image:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    for comment in await db_image.awaitable_attrs.comments:\n        if comment.id == comment_id:\n            await db.delete(comment)\n            await db.commit()\n            await db.refresh(db_image)\n            break\n    else:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Comment not found\"}, status_code=404\n        )\n\n    return JSONResponse({\"success\": True})"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers"],"accepts_unauthenticated_input":false,"risk_level":"high","security_concerns":[{"vulnerability_type":"authorization_bypass","description":"Deletes a comment by ID after fetching an image with get_image(db, image_id, user.id). Need to verify that get_image enforces proper ownership/permissions and that users are authorized to delete comments on the image (e.g., only image owner or comment owner). Otherwise, authenticated users could delete comments they shouldn’t.","confidence":0.6},{"vulnerability_type":"business_logic","description":"Uses POST to a delete endpoint; ensure this is intentional and protected against CSRF if cookies/session auth is ever used. Confirm expected policy (who may delete which comments) and that it’s enforced.","confidence":0.5}],"endpoint_path":"/{image_id}/comments/{comment_id}/delete","http_methods":["POST"],"has_input_validation":true,"has_sanitization":false,"has_authorization_check":true,"reasoning":"This is a real FastAPI route that accepts path parameters (UUID4) and requires an authenticated user via Depends(deps.get_current_user). It performs database reads and a write (deletion) based on user-supplied IDs, which is a sensitive operation. Prioritize as HIGH for review to confirm authorization logic and business rules are correctly enforced and that there is no way for an authenticated user to delete comments they are not permitted to. Input is type-validated via UUID4 annotations but no additional sanitization is relevant here."}
