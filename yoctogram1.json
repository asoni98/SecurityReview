{"function_name":"users_me","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/users.py","line_number":17,"column":null,"snippet":"@router.get(\"/me\", response_model=UserDetail)\nasync def users_me(current_user: UserDetail = Depends(deps.get_current_user)):\n    return current_user"},"framework":"FastAPI","language":"python","input_sources":["http_headers","cookies"],"accepts_unauthenticated_input":false,"risk_level":"low","security_concerns":[{"vulnerability_type":"authorization_bypass","description":"Relies on deps.get_current_user for authentication; ensure it properly enforces auth (token/session validation) and cannot be bypassed.","confidence":0.5}],"endpoint_path":"/me","http_methods":["GET"],"has_input_validation":null,"has_sanitization":null,"has_authorization_check":true,"reasoning":"This is a real FastAPI API handler. It requires authentication via Depends(deps.get_current_user) and simply returns the current user object. Read-only with minimal logic and protected by auth, so low priority for deep security review."}
{"function_name":"api_health_check","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/api.py","line_number":7,"column":null,"snippet":"@api_router.get(\"/health\", status_code=status.HTTP_200_OK)\nasync def api_health_check() -> Response:\n    return Response(status_code=status.HTTP_200_OK)"},"framework":"Fastapi","language":"python","input_sources":[],"accepts_unauthenticated_input":true,"risk_level":"low","security_concerns":[],"endpoint_path":"/health","http_methods":["GET"],"has_input_validation":false,"has_sanitization":false,"has_authorization_check":false,"reasoning":"This is a real FastAPI endpoint: GET /health. It returns a static 200 Response and does not read request body, params, or headers. No authentication or authorization is applied, but the handler performs no sensitive operations (no DB, file, external calls). As an unauthenticated, trivial health check, it poses minimal risk and warrants LOW priority. Note: the rest of the file mostly wires in other routers (auth, users, images, feed, social) which should be triaged separately; this specific handler is simple."}
{"function_name":"users_username_from_id","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/users.py","line_number":23,"column":null,"snippet":"@router.get(\"/profile/{user}\")\nasync def users_username_from_id(\n    user: uuid.UUID, db: AsyncDBSession = Depends(deps.get_db)\n) -> JSONResponse:\n    try:\n        db_user = (await db.scalars(select(User).where(User.id == user))).first()\n        if not db_user:\n            return JSONResponse(\n                content={\"success\": False, \"detail\": \"User not found\"},\n                status_code=404,\n            )\n\n        return JSONResponse(\n            content={\"success\": True, \"username\": db_user.username, \"bio\": db_user.bio}\n        )\n    except Exception as e:\n        await logger.aexception(\"Error fetching user profile\", user=user)\n        return JSONResponse(\n            {\n                \"success\": False,\n                \"detail\": str(e) if settings.DEBUG else \"Internal server error\",\n            },\n            status_code=500,\n        )"},"framework":"Fastapi","language":"python","input_sources":["path_params"],"accepts_unauthenticated_input":true,"risk_level":"medium","security_concerns":[{"vulnerability_type":"other","description":"Unauthenticated endpoint exposes profile information (username, bio). Confirm this data is intended to be public and assess risk of user enumeration via UUIDs.","confidence":0.7},{"vulnerability_type":"business_logic","description":"No authorization check; ensure business rule allows any caller to retrieve profile details by user ID.","confidence":0.7}],"endpoint_path":"/profile/{user}","http_methods":["GET"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":false,"reasoning":"This is a real FastAPI GET route that handles a path parameter 'user' (UUID) and performs a database lookup using that input. There is no authentication dependency on this endpoint (unlike the /me route), so it accepts unauthenticated requests. It executes a read-only DB query and returns limited profile data. Input is type-validated by FastAPI (UUID) and SQLAlchemy parameterization reduces injection risk. Main security considerations are around data exposure/business logic (should this be public?) and any error detail leakage when DEBUG is enabled. Prioritized as MEDIUM: unauthenticated read with simple logic and DB access; not performing writes or sensitive operations."}
{"function_name":"auth_register","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/auth.py","line_number":19,"column":null,"snippet":"@router.post(\"/register/\", status_code=201)\nasync def auth_register(\n    user: UserCreate, db: AsyncDBSession = Depends(deps.get_db)\n) -> Response:\n    try:\n        db_user = (\n            await db.scalars(\n                select(User).where(\n                    or_(User.username == user.username, User.email == user.email)\n                )\n            )\n        ).first()\n        if db_user:\n            return JSONResponse(\n                content={\n                    \"success\": False,\n                    \"detail\": \"Email or username already registered\",\n                },\n                status_code=400,\n            )\n\n        hashed_password = get_password_hash(user.password)\n\n        db_user = User(\n            **user.model_dump(exclude={\"password\"}), password_hash=hashed_password\n        )\n        db.add(db_user)\n        await db.commit()\n        await db.refresh(db_user)"},"framework":"Fastapi","language":"python","input_sources":["http_body"],"accepts_unauthenticated_input":true,"risk_level":"critical","security_concerns":[{"vulnerability_type":"mass_assignment","description":"User model is constructed via **user.model_dump(...). If the UserCreate schema permits sensitive fields (e.g., is_admin, roles), client-controlled fields could be written to the database.","confidence":0.7},{"vulnerability_type":"business_logic","description":"Unauthenticated account creation without visible rate limiting, email verification, or strong uniqueness enforcement may allow abuse, user enumeration (distinct error for existing account), and TOCTOU on uniqueness unless DB unique constraints are enforced.","confidence":0.6}],"endpoint_path":"/register/","http_methods":["POST"],"has_input_validation":true,"has_sanitization":false,"has_authorization_check":false,"reasoning":"This is a real FastAPI route handler that accepts a Pydantic model from the HTTP request body and performs database reads and writes to create a new user. No authentication is required. Because it accepts unauthenticated input and performs sensitive operations (DB insert of a new account and password hashing), it warrants CRITICAL priority for security review. Key areas include schema restrictions to prevent mass assignment and business-logic defenses (rate limiting, unique constraints, enumeration resistance)."}
{"function_name":"auth_login","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/auth.py","line_number":60,"column":null,"snippet":null},"framework":"Fastapi","language":"python","input_sources":["http_body"],"accepts_unauthenticated_input":true,"risk_level":"critical","security_concerns":[{"vulnerability_type":"business_logic","description":"No apparent rate limiting, lockout, or anti-bruteforce on the login endpoint. Review for user enumeration and throttling protections.","confidence":0.5},{"vulnerability_type":"authentication_bypass","description":"Authentication and token issuance logic should be reviewed to ensure secure password verification and correct JWT creation (algorithm/secret/claims, expiration).","confidence":0.5},{"vulnerability_type":"other","description":"Error handling returns exception details when DEBUG is true, which may leak sensitive information. Verify operational configuration.","confidence":0.4}],"endpoint_path":"/login/","http_methods":["POST"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":false,"reasoning":"This is a real FastAPI route handler (router.post) for POST /login/. It accepts unauthenticated JSON body mapped to the UserLogin model (username, password). It queries the database for the user, verifies the password, and issues a JWT access tokenâ€”sensitive authentication operations exposed to unauthenticated users. That makes it high-priority for review. Focus on DB query and password verification, JWT creation, error handling, and absence of rate limiting or lockout which could allow brute-force attempts."}
{"function_name":"images_generate_upload_link","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/images.py","line_number":21,"column":null,"snippet":"@router.post(\"/upload/{privacy}/generate\")\nasync def images_generate_upload_link(\n    privacy: str,\n    caption: str = \"\",\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n    aws: AWSSession = Depends(deps.get_aws_session),\n) -> Response:\n    if privacy not in [\"public\", \"private\"]:\n        return JSONResponse(\n            content={\n                \"success\": False,\n                \"detail\": \"privacy parameter should be 'public' or 'private'\",\n            },\n            status_code=400,\n        )\n\n    public = privacy == \"public\"\n    image_id = str(ULID().to_uuid4())\n    db_image = Image(\n        id=image_id,\n        public=public,\n        caption=caption,\n        owner_id=user.id,\n        content_type=\"image/jpeg\",\n    )\n\n    presigned_post = create_presigned_post(aws, image_id)\n    db_image.path = presigned_post[\"s3_uri\"]\n    create_response = presigned_post[\"create_response\"] | {\"id\": image_id}"},"framework":"Fastapi","language":"python","input_sources":["path_params","query_params","http_headers"],"accepts_unauthenticated_input":false,"risk_level":"high","security_concerns":[{"vulnerability_type":"business_logic","description":"Generates S3 presigned POST allowing client-side uploads; review constraints (ACL, content-type, max size, allowed key prefix, expiry) and ensure only intended users can generate and subsequently access/modify the resource.","confidence":0.83},{"vulnerability_type":"other","description":"Caption is accepted from user and stored on Image model without apparent length/content validation; assess for downstream XSS/validation issues where caption is rendered or used.","confidence":0.7},{"vulnerability_type":"authorization_bypass","description":"Relies on get_current_user for authentication; verify it enforces auth and that no path allows anonymous access to generate upload links.","confidence":0.6}],"endpoint_path":"/upload/{privacy}/generate","http_methods":["POST"],"has_input_validation":true,"has_sanitization":false,"has_authorization_check":true,"reasoning":"This is a real FastAPI POST endpoint that accepts path and query parameters and depends on authenticated user context. It performs sensitive operations: generating AWS S3 presigned upload parameters and preparing a DB model for an image. While it appears authenticated, the operations are impactful (file upload capability, potential DB write), warranting a HIGH priority review."}
{"function_name":"images_confirm_uploaded","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/images.py","line_number":59,"column":null,"snippet":null},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers"],"accepts_unauthenticated_input":false,"risk_level":"medium","security_concerns":[{"vulnerability_type":"authorization_bypass","description":"Relies on owner check (db_image.owner_id == user.id); ensure get_current_user cannot be bypassed and owner check is always enforced for this route.","confidence":0.7},{"vulnerability_type":"business_logic","description":"Confirms upload after checking object existence in S3; review for race conditions/TOCTOU or ability to confirm objects not properly uploaded.","confidence":0.6}],"endpoint_path":"/upload/{image_id}/confirm","http_methods":["POST"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":true,"reasoning":"This is a real FastAPI route handler that accepts a path parameter (image_id) and requires authentication via Depends(deps.get_current_user). It performs DB read and write operations and an external AWS S3 existence check before marking an image as uploaded. Because it is authenticated and performs a state-changing DB update, it warrants a MEDIUM priority review. Reviewers should focus on authorization correctness (owner check) and the S3 verification/confirmation logic for business logic flaws."}
{"function_name":"images_retrieve","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/images.py","line_number":93,"column":null,"snippet":"@router.get(\"/media/{image_id}\")\nasync def images_retrieve(\n    image_id: UUID4,\n    user: UserDetail | None = Depends(deps.verify_jwt_to_uuid_or_none),\n    db: AsyncDBSession = Depends(deps.get_db),\n    aws: AWSSession = Depends(deps.get_aws_session),\n    redis: Redis = Depends(deps.get_redis),\n) -> Response:\n    try:\n        user_id = user.id if user is not None else None\n        db_image = await get_image(db, image_id, user_id)\n        if not db_image:\n            return JSONResponse(\n                {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n            )\n\n        return JSONResponse(\n            {\n                \"success\": True,\n                \"uri\": await presigned_url_with_cache(\n                    aws, redis, db_image.path, db_image.content_type\n                ),\n            }\n        )"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers"],"accepts_unauthenticated_input":true,"risk_level":"high","security_concerns":[{"vulnerability_type":"idor","description":"Optional authentication allows unauthenticated access to image retrieval. If get_image does not strictly enforce ownership/visibility, attackers could enumerate UUIDs and obtain pre-signed S3 URLs for other users' images (Insecure Direct Object Reference).","confidence":0.7},{"vulnerability_type":"other","description":"Function returns a pre-signed S3 URL derived from DB fields. If access control is weak, this may leak access to private bucket objects and metadata (path, content type).","confidence":0.5}],"endpoint_path":"/media/{image_id}","http_methods":["GET"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":null,"reasoning":"This is a real FastAPI route handler. It accepts a path parameter image_id and optionally an Authorization header (user may be None), so unauthenticated users can hit it. It reads from the database via get_image and returns a pre-signed S3 URL using AWS and Redis, making external calls and potentially exposing sensitive resources. Because it is unauthenticated read with non-trivial logic and potential access control implications (IDOR), it should be prioritized as HIGH."}
{"function_name":"feed_latest","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/feed.py","line_number":22,"column":null,"snippet":"@router.get(\"/latest\")\nasync def feed_latest(\n    before: datetime = datetime.now(tz=timezone.utc) + timedelta(days=1),\n    after: datetime = datetime.fromtimestamp(0, tz=timezone.utc),\n    user: UserDetail | None = Depends(deps.verify_jwt_to_uuid_or_none),\n    db: AsyncDBSession = Depends(deps.get_db),\n    aws: AWSSession = Depends(deps.get_aws_session),\n    redis: Redis = Depends(deps.get_redis),\n) -> Response:\n    try:\n        before = before.astimezone(timezone.utc).replace(tzinfo=None)\n        after = after.astimezone(timezone.utc).replace(tzinfo=None)\n\n        image_filters = [\n            Image.created_at < before,\n            Image.created_at > after,\n            Image.public,\n        ]\n\n        if user is not None:\n            image_filters[-1] = or_(Image.public, Image.owner_id == user.id)\n\n        return JSONResponse(await build_feed(image_filters, db, aws, redis))\n    except Exception as e:\n        await logger.aexception(\"Error building latest feed\", user=user.id)\n        return JSONResponse(\n            {\n                \"success\": False,\n                \"detail\": str(e) if settings.DEBUG else \"Internal server error\",\n            },"},"framework":"Fastapi","language":"python","input_sources":["query_params","http_headers","cookies"],"accepts_unauthenticated_input":true,"risk_level":"high","security_concerns":[{"vulnerability_type":"business_logic","description":"Unauthenticated users can call this endpoint and influence database query time bounds via before/after query params. Reviewer should ensure filtering and visibility logic (public vs. owner content) is correct and cannot leak private data.","confidence":0.7}],"endpoint_path":"/latest","http_methods":["GET"],"has_input_validation":false,"has_sanitization":null,"has_authorization_check":false,"reasoning":"This is a real FastAPI route handler (GET /latest). It accepts unauthenticated requests (user dependency allows None) and processes query parameters (before, after) to build database filters. It then calls build_feed with DB session, AWS session, and Redis client, implying DB reads and external/caching interactions. Because it is reachable without auth and performs non-trivial logic touching the database and external services (AWS, Redis), it warrants a HIGH priority review. Focus on how before/after are parsed and used, visibility rules for public vs owner content, any downstream use of AWS/Redis driven by these inputs, and error handling that may leak details in DEBUG."}
{"function_name":"feed_by_user","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/feed.py","line_number":56,"column":null,"snippet":"@router.get(\"/by_user/{creator}\")\nasync def feed_by_user(\n    creator: uuid.UUID,\n    before: datetime = datetime.now(tz=timezone.utc) + timedelta(days=1),\n    after: datetime = datetime.fromtimestamp(0, tz=timezone.utc),\n    user: UserDetail | None = Depends(deps.verify_jwt_to_uuid_or_none),\n    db: AsyncDBSession = Depends(deps.get_db),\n    aws: Optional[AWSSession] = Depends(deps.get_aws_session),\n    redis: Redis = Depends(deps.get_redis),\n) -> Response:\n    ..."},"framework":"Fastapi","language":"python","input_sources":["path_params","query_params","http_headers"],"accepts_unauthenticated_input":true,"risk_level":"high","security_concerns":[{"vulnerability_type":"authorization_bypass","description":"Authorization is enforced via query filters (or_(Image.owner_id == user.id, Image.public)) with optional authentication. If user is None or logic is flawed, private images may be exposed. Verify behavior when user is unauthenticated and how build_feed applies filters.","confidence":0.7},{"vulnerability_type":"idor","description":"Path parameter 'creator' is a UUID of the content owner. Ensure that unauthenticated users can only access public resources and that enumeration does not leak private data or metadata.","confidence":0.6},{"vulnerability_type":"business_logic","description":"Complex filtering logic (date range, owner, public/owner match) is used to gate access. Any mistakes in combining filters or handling timezones could leak or omit data. Also confirm that user Optional state is handled safely when constructing filters.","confidence":0.7}],"endpoint_path":"/by_user/{creator}","http_methods":["GET"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":true,"reasoning":"This is a real FastAPI GET endpoint handling unauthenticated requests with optional JWT-based identity. It accepts path and query parameters and uses them to build SQLAlchemy filters, then invokes build_feed with DB, AWS, and Redis sessions. While it appears read-only, it enforces access control via business logic in the filters and interacts with multiple backends, making it higher priority to ensure no data exposure due to logic errors, especially when user is None."}
{"function_name":"images_like","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":16,"column":null,"snippet":"@router.post(\"/{image_id}/like\")\nasync def images_like(\n    image_id: UUID4,\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n) -> Response:\n    db_image = await get_image(db, image_id, user.id)\n    if not db_image:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    if (\n        await db.scalars(\n            select(Like).where(Like.user_id == user.id, Like.image_id == image_id)\n        )\n    ).first():\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"User has already liked this image\"},\n            status_code=400,\n        )\n\n    (await db_image.awaitable_attrs.likes).append(\n        Like(user_id=user.id, image_id=image_id, image=db_image)\n    )\n    await db.commit()\n    await db.refresh(db_image)\n\n    return JSONResponse({\"success\": True})"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers"],"accepts_unauthenticated_input":false,"risk_level":"medium","security_concerns":[{"vulnerability_type":"idor","description":"Verify get_image enforces proper authorization/visibility rules so users cannot like images they should not be able to access (e.g., private/other-tenant content).","confidence":0.4},{"vulnerability_type":"business_logic","description":"Duplicate-like prevention relies on an application check; ensure a DB-level unique constraint on (user_id, image_id) to prevent race-condition duplicates.","confidence":0.6}],"endpoint_path":"/{image_id}/like","http_methods":["POST"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":true,"reasoning":"This is a real FastAPI route handler (router.post) that accepts a UUID path parameter and uses an authenticated user from Depends(get_current_user). It performs DB reads and a write to create a Like, then commits the transaction. It is authenticated and performs standard CRUD DB operations, so prioritize as MEDIUM. Reviewers should focus on authorization within get_image and ensuring robust duplicate-like prevention/constraints."}
{"function_name":"images_like","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":47,"column":null,"snippet":"@router.post(\"/{image_id}/like\")\nasync def images_like(\n    image_id: UUID4,\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n) -> Response:\n    db_image = await get_image(db, image_id, user.id)\n    if not db_image:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    if (\n        await db.scalars(\n            select(Like).where(Like.user_id == user.id, Like.image_id == image_id)\n        )\n    ).first():\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"User has already liked this image\"},\n            status_code=400,\n        )\n\n    (await db_image.awaitable_attrs.likes).append(\n        Like(user_id=user.id, image_id=image_id, image=db_image)\n    )\n    await db.commit()\n    await db.refresh(db_image)\n\n    return JSONResponse({\"success\": True})"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers","cookies"],"accepts_unauthenticated_input":false,"risk_level":"medium","security_concerns":[{"vulnerability_type":"idor","description":"Path param image_id may allow acting on images not intended to be accessible. Verify get_image(db, image_id, user.id) enforces visibility/ownership properly.","confidence":0.7},{"vulnerability_type":"business_logic","description":"Duplicate-like prevention is implemented in application logic. Check for race conditions and whether a DB-level unique constraint exists on (user_id, image_id).","confidence":0.6},{"vulnerability_type":"sql_injection","description":"ORM (SQLAlchemy) with bound parameters appears to be used, which is typically safe. Confirm no raw SQL in get_image or related model loaders.","confidence":0.3},{"vulnerability_type":"authorization_bypass","description":"Ensure deps.get_current_user reliably enforces authentication and that authorization checks in get_image prevent unauthorized interactions with restricted images.","confidence":0.6}],"endpoint_path":"/{image_id}/like","http_methods":["POST"],"has_input_validation":true,"has_sanitization":true,"has_authorization_check":true,"reasoning":"This is a real FastAPI route handler that accepts a path parameter (UUID4) and uses authenticated user context via Depends(deps.get_current_user). It performs database reads and writes (creating a Like, committing the transaction). Because it requires authentication and performs standard CRUD DB operations, it warrants MEDIUM priority. Next review should focus on access control around image visibility (get_image), race conditions/uniqueness on likes, and correct use of ORM to avoid raw SQL."}
{"function_name":"images_unlike","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":74,"column":null,"snippet":"@router.post(\"/{image_id}/unlike\")\nasync def images_unlike(\n    image_id: UUID4,\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n) -> Response:\n    db_image = await get_image(db, image_id, user.id)\n    if not db_image:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    for like in await db_image.awaitable_attrs.likes:\n        if like.user_id == user.id:\n            await db.delete(like)\n            await db.commit()\n            await db.refresh(db_image)\n            break\n    else:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"User has not liked this image\"},\n            status_code=400,\n        )\n\n    return JSONResponse({\"success\": True})"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers"],"accepts_unauthenticated_input":false,"risk_level":"high","security_concerns":[{"vulnerability_type":"authorization_bypass","description":"Potential IDOR/authorization gaps depend on how get_image(db, image_id, user.id) enforces access. If get_image does not strictly scope the image to the authenticated userâ€™s visibility rules, a user might interact with records they shouldnâ€™t.","confidence":0.6},{"vulnerability_type":"business_logic","description":"Logic relies on iterating likes and matching like.user_id == user.id before deletion. Ensure there are no race conditions or cases where multiple likes or unexpected state could be exploited.","confidence":0.5}],"endpoint_path":"/{image_id}/unlike","http_methods":["POST"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":true,"reasoning":"This is a real FastAPI POST route that accepts an authenticated user and a UUID path parameter. It uses the userâ€™s auth context (Depends(deps.get_current_user)) and performs database reads and a write (deletes a like and commits). Because it is authenticated yet performs state-changing DB operations, it merits a HIGH priority review. Reviewers should focus on authorization enforcement in get_image and ensure only the owner of the like is affected, as well as correctness and race conditions around the deletion loop and commit."}
{"function_name":"images_get_likes","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":97,"column":null,"snippet":"@router.get(\"/{image_id}/likes\")\nasync def images_get_likes(\n    image_id: UUID4,\n    user: UserDetail | None = Depends(deps.verify_jwt_to_uuid_or_none),\n    db: AsyncDBSession = Depends(deps.get_db),\n) -> Response:\n    db_image = await get_image(db, image_id, user.id)\n    if not db_image:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    liking_users = [\n        {\n            \"id\": str(like.user_id),\n            \"username\": (await like.awaitable_attrs.user).username,\n        }\n        for like in await db_image.awaitable_attrs.likes\n    ]\n\n    return JSONResponse({\"success\": True, \"likes\": liking_users})"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers"],"accepts_unauthenticated_input":true,"risk_level":"low","security_concerns":[{"vulnerability_type":"authorization_bypass","description":"Endpoint allows unauthenticated access (user is optional). Ensure get_image(...) enforces visibility/access rules for the requested image, otherwise users may enumerate likes on private images.","confidence":0.6},{"vulnerability_type":"idor","description":"User-controlled image_id path parameter selects the resource. Verify get_image applies proper ownership/visibility checks to prevent access to likes of images the caller should not see.","confidence":0.55},{"vulnerability_type":"other","description":"Potential data exposure: returns liker user IDs and usernames publicly. Confirm this is intended and complies with privacy requirements; consider rate limiting to prevent scraping.","confidence":0.6}],"endpoint_path":"/{image_id}/likes","http_methods":["GET"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":false,"reasoning":"This is a real FastAPI route handler that accepts a path parameter (image_id) and optional JWT from headers. It is reachable by unauthenticated users (verify_jwt_to_uuid_or_none), performs database reads (fetch image and related likes/users), and returns JSON. No writes or file/system/command operations occur, so impact is lower; however, it is unauthenticated and exposes relational data. Prioritize as LOW for security review, focusing on access-control enforcement in get_image and potential information disclosure."}
{"function_name":"images_comment","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":124,"column":null,"snippet":"@router.post(\"/{image_id}/comment\")\nasync def images_comment(\n    image_id: UUID4,\n    comment: CommentCreate,\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n) -> Response:\n    db_image = await get_image(db, image_id, user.id)\n    if not db_image:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    (await db_image.awaitable_attrs.comments).append(\n        Comment(\n            id=ULID().to_uuid4(),\n            user_id=user.id,\n            image_id=image_id,\n            content=comment.content,\n        )\n    )\n    await db.commit()\n    await db.refresh(db_image)\n\n    return JSONResponse({\"success\": True})"},"framework":"Fastapi","language":"python","input_sources":["path_params","http_body","http_headers"],"accepts_unauthenticated_input":false,"risk_level":"medium","security_concerns":[{"vulnerability_type":"xss","description":"User-supplied comment.content is stored in the database and may later be rendered; verify output encoding/sanitization where comments are displayed to prevent stored XSS.","confidence":0.6},{"vulnerability_type":"idor","description":"image_id is a path parameter; ensure get_image(db, image_id, user.id) enforces proper authorization/visibility and that users cannot comment on images they are not allowed to interact with.","confidence":0.5},{"vulnerability_type":"business_logic","description":"Check constraints on comment size/content, rate limiting, and spam/abuse controls; absence could enable abuse even if technically correct.","confidence":0.5}],"endpoint_path":"/{image_id}/comment","http_methods":["POST"],"has_input_validation":true,"has_sanitization":false,"has_authorization_check":true,"reasoning":"This is a real FastAPI route handler that processes a POST to /{image_id}/comment. It accepts user input via a path parameter (image_id) and a request body (CommentCreate), and depends on get_current_user for authentication, so unauthenticated users should not reach it. It performs database operations: looks up the image and appends a new Comment entity, then commits. Because it is authenticated and performs standard CRUD DB writes, it warrants a MEDIUM priority review. The reviewer should focus on authorization in get_image, validation and sanitization of comment.content, and any downstream rendering that could introduce stored XSS or IDOR issues."}
{"function_name":"images_comment","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":152,"column":null,"snippet":"@router.post(\"/{image_id}/comments/{comment_id}/update\")\nasync def images_comment(\n    image_id: UUID4,\n    comment_id: UUID4,\n    comment: CommentCreate,\n    user: UserDetail = Depends(deps.get_current_user),\n    db: AsyncDBSession = Depends(deps.get_db),\n) -> Response:\n    db_image = await get_image(db, image_id, user.id)\n    if not db_image:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Image not found\"}, status_code=404\n        )\n\n    for db_comment in await db_image.awaitable_attrs.comments:\n        if db_comment.id == comment_id:\n            db_comment.content = comment.content\n            await db.commit()\n            await db.refresh(db_image)\n            break\n    else:\n        return JSONResponse(\n            {\"success\": False, \"detail\": \"Comment not found\"}, status_code=404\n        )\n\n    return JSONResponse({\"success\": True})"},"framework":"Fastapi","language":"python","input_sources":["http_body","path_params"],"accepts_unauthenticated_input":false,"risk_level":"high","security_concerns":[{"vulnerability_type":"idor","description":"Authorization appears to rely on get_image(db, image_id, user.id), which likely restricts images to the current user. However, the handler allows updating any comment attached to that image, potentially including comments authored by other users. Confirm that business rules permit this; otherwise, it may be an IDOR.","confidence":0.6},{"vulnerability_type":"xss","description":"User-supplied comment.content is written to the database without sanitization. If later rendered in HTML without proper escaping, this could lead to stored XSS.","confidence":0.4}],"endpoint_path":"/{image_id}/comments/{comment_id}/update","http_methods":["POST"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":true,"reasoning":"This is a real FastAPI route that accepts path parameters (image_id, comment_id) and a request body (CommentCreate). It requires authentication via Depends(deps.get_current_user). It performs database reads and a write (updating a comment's content) followed by a commit, which is a sensitive operation. While there is an authorization check tied to the image/user relationship via get_image, it is unclear if comment ownership is enforced, presenting potential IDOR/business-logic risks. The lack of explicit sanitization also raises stored XSS concerns depending on downstream rendering. Authenticated + DB write => HIGH priority for review."}
{"function_name":"images_comment","location":{"file_path":"/Users/arunsoni/SecurityReview/yoctogram-app-main/app/api/v1/endpoints/social.py","line_number":179,"column":null,"snippet":null},"framework":"Fastapi","language":"python","input_sources":["path_params","http_headers"],"accepts_unauthenticated_input":false,"risk_level":"high","security_concerns":[{"vulnerability_type":"authorization_bypass","description":"Deletion is gated by authentication and a get_image(db, image_id, user.id) lookup. Verify get_image enforces ownership/permissions; otherwise a user could potentially delete comments on images they should not control.","confidence":0.55},{"vulnerability_type":"idor","description":"Comment deletion is based on a comment_id path param. Although the code restricts deletion to comments attached to the fetched image, confirm that the image truly belongs to/accessible by the requester to avoid IDOR.","confidence":0.4},{"vulnerability_type":"business_logic","description":"Confirm the intended permission model (e.g., image owner vs. comment author) and that the check in get_image correctly limits who can delete comments.","confidence":0.5}],"endpoint_path":"/{image_id}/comments/{comment_id}/delete","http_methods":["POST"],"has_input_validation":true,"has_sanitization":null,"has_authorization_check":true,"reasoning":"This is a real FastAPI POST route that accepts path params and an authenticated user via dependency injection. It performs a database lookup and deletes a comment (DB write) based on user-supplied identifiers. Authentication is required, but authorization depends on get_image enforcing ownership. Because it is an authenticated endpoint performing sensitive DB modifications, it warrants HIGH priority review."}
